<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="第一章 正则表达式字符匹配攻略1.1 两种模糊匹配如果正则只有精确匹配是没多大意义的，比如/hello/，也只能匹配字符串中的”hello”这个子串 var regex = /hello/;console.log( regex.test(“hello”) );// =&amp;gt; true正则表达式之所以强大，是因为其能实现模糊匹配而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊1.1.1 横向">
<meta name="keywords" content="正则表达式">
<meta property="og:type" content="article">
<meta property="og:title" content="正则表达式学习">
<meta property="og:url" content="http://yoursite.com/2019/01/15/正则表达式学习/index.html">
<meta property="og:site_name" content="大可空间">
<meta property="og:description" content="第一章 正则表达式字符匹配攻略1.1 两种模糊匹配如果正则只有精确匹配是没多大意义的，比如/hello/，也只能匹配字符串中的”hello”这个子串 var regex = /hello/;console.log( regex.test(“hello”) );// =&amp;gt; true正则表达式之所以强大，是因为其能实现模糊匹配而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊1.1.1 横向">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-14T16:12:34.375Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="正则表达式学习">
<meta name="twitter:description" content="第一章 正则表达式字符匹配攻略1.1 两种模糊匹配如果正则只有精确匹配是没多大意义的，比如/hello/，也只能匹配字符串中的”hello”这个子串 var regex = /hello/;console.log( regex.test(“hello”) );// =&amp;gt; true正则表达式之所以强大，是因为其能实现模糊匹配而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊1.1.1 横向">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>正则表达式学习</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Inici</a></li>
         
          <li><a href="/about/">Qui som</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/projects_url">Projectes</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/01/21/linux日志文件自动替换/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2018/09/11/失去也是得到/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Post Anterior</span>
      <span id="i-next" class="info" style="display:none;">Post Següent</span>
      <span id="i-top" class="info" style="display:none;">Adalt</span>
      <span id="i-share" class="info" style="display:none;">Compartir Post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/01/15/正则表达式学习/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/01/15/正则表达式学习/&text=正则表达式学习"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/01/15/正则表达式学习/&title=正则表达式学习"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/01/15/正则表达式学习/&is_video=false&description=正则表达式学习"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=正则表达式学习&body=Check out this article: http://yoursite.com/2019/01/15/正则表达式学习/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/01/15/正则表达式学习/&title=正则表达式学习"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/01/15/正则表达式学习/&title=正则表达式学习"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/01/15/正则表达式学习/&title=正则表达式学习"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/01/15/正则表达式学习/&title=正则表达式学习"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/01/15/正则表达式学习/&name=正则表达式学习&description=&lt;p&gt;&lt;strong&gt;第一章 正则表达式字符匹配攻略&lt;/strong&gt;&lt;br&gt;1.1 两种模糊匹配&lt;br&gt;如果正则只有精确匹配是没多大意义的，比如/hello/，也只能匹配字符串中的”hello”这个子串&lt;/p&gt;
&lt;p&gt;var regex = /hello/;&lt;br&gt;console.log( regex.test(“hello”) );&lt;br&gt;// =&amp;gt; true&lt;br&gt;正则表达式之所以强大，是因为其能实现模糊匹配&lt;br&gt;而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊&lt;br&gt;1.1.1 横向模糊匹配&lt;br&gt;横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的&lt;br&gt;其实现的方式是使用量词。譬如{m,n}，表示连续出现最少m次，最多n次&lt;br&gt;比如/ab{2,5}c/表示匹配这样一个字符串：第一个字符是“a”，接下来是2到5个字符“b”，最后是字符“c”。测试如下&lt;br&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        正则表达式学习
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">大可空间</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-01-14T16:03:10.000Z" itemprop="datePublished">2019-01-15</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/正则/">正则</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/正则表达式/">正则表达式</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p><strong>第一章 正则表达式字符匹配攻略</strong><br>1.1 两种模糊匹配<br>如果正则只有精确匹配是没多大意义的，比如/hello/，也只能匹配字符串中的”hello”这个子串</p>
<p>var regex = /hello/;<br>console.log( regex.test(“hello”) );<br>// =&gt; true<br>正则表达式之所以强大，是因为其能实现模糊匹配<br>而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊<br>1.1.1 横向模糊匹配<br>横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的<br>其实现的方式是使用量词。譬如{m,n}，表示连续出现最少m次，最多n次<br>比如/ab{2,5}c/表示匹配这样一个字符串：第一个字符是“a”，接下来是2到5个字符“b”，最后是字符“c”。测试如下<br><a id="more"></a><br>var regex = /ab{2,5}c/g;<br>var string = “abc abbc abbbc abbbbc abbbbbc abbbbbbc”;<br>console.log( string.match(regex) );<br>// =&gt; [“abbc”, “abbbc”, “abbbbc”, “abbbbbc”]<br>1.1.2 纵向模糊匹配<br>纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能</p>
<p>其实现的方式是使用字符组。譬如[abc]，表示该字符是可以字符“a”、“b”、“c”中的任何一个<br>var regex = /a[123]b/g;<br>var string = “a0b a1b a2b a3b a4b”;<br>console.log( string.match(regex) );<br>// =&gt; [“a1b”, “a2b”, “a3b”]<br>只要掌握横向和纵向模糊匹配，就能解决很大部分正则匹配问题</p>
<p>1.2 字符组<br>需要强调的是，虽叫字符组（字符类），但只是其中一个字符。例如[abc]，表示匹配一个字符，它可以是“a”、“b”、“c”之一</p>
<p>1.2.1 范围表示法<br>如果字符组里的字符特别多的话，怎么办？可以使用范围表示法</p>
<p>如果字符组里的字符特别多的话，怎么办？可以使用范围表示法<br>比如[123456abcdefGHIJKLM]，可以写成[1-6a-fG-M]。用连字符-来省略和简写<br>因为连字符有特殊用途，那么要匹配“a”、“-”、“z”这三者中任意一个字符，该怎么做呢？<br>不能写成[a-z]，因为其表示小写字符中的任何一个字符。<br>可以写成如下的方式：[-az]或[az-]或[a-z]。即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了<br>1.2.2 排除字符组<br>纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是”a”、”b”、”c”<br>此时就是排除字符组（反义字符组）的概念。例如[^abc]，表示是一个除”a”、”b”、”c”之外的任意一个字符。字符组的第一位放^（脱字符），表示求反的概念<br>1.2.3 常见的简写形式<br>有了字符组的概念后，一些常见的符号我们也就理解了。因为它们都是系统自带的简写形式</p>
<p>\d就是[0-9]。表示是一位数字。记忆方式：其英文是digit（数字）<br>D就是[^0-9]。表示除数字外的任意字符<br>\w就是[0-9a-zA-Z<em>]。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符。<br>`W是[^0-9a-zA-Z</em>]`。非单词字符<br>\s是[ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母<br>\S是[^ \t\v\n\r\f]。 非空白符<br>.就是[^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号…中的每个点，都可以理解成占位符，表示任何类似的东西<br>如果要匹配任意字符怎么办？可以使用[\d\D]、[\w\W]、[\s\S]和[^]中任何的一个。</p>
<p>1.3 量词<br>量词也称重复。掌握{m,n}的准确含义后，只需要记住一些简写形式</p>
<p>1.3.1 简写形式<br>{m,}表示至少出现m次<br>{m} 等价于{m,m}，表示出现m次<br>? 等价于{0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？</p>
<ul>
<li>等价于{1,}，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加</li>
</ul>
<ul>
<li>等价于{0,}，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来<br>1.3.2 贪婪匹配和惰性匹配<br>var regex = /\d{2,5}/g;<br>var string = “123 1234 12345 123456”;<br>console.log( string.match(regex) );<br>// =&gt; [“123”, “1234”, “12345”, “12345”]<br>其中正则/\d{2,5}/，表示数字连续出现2到5次。会匹配2位、3位、4位、5位连续数字<br>但是其是贪婪的，它会尽可能多的匹配。你能给我6个，我就要5个。你能给我3个，我就3要个。反正只要在能力范围内，越多越好<br>我们知道有时贪婪不是一件好事（请看文章最后一个例子）。而惰性匹配，就是尽可能少的匹配<br>var regex = /\d{2,5}?/g;<br>var string = “123 1234 12345 123456”;<br>console.log( string.match(regex) );<br>// =&gt; [“12”, “12”, “34”, “12”, “34”, “12”, “34”, “56”]<br>其中/\d{2,5}?/表示，虽然2到5次都行，当2个就够的时候，就不在往下尝试了</li>
</ul>
<p>通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下<br>{m,n}?<br>{m,}?<br>??<br>+?<br><em>?<br>.</em> 是贪婪模式<br>.*? 是勉强模式<br>对惰性匹配的记忆方式是：量词后面加个问号，问一问你知足了吗，你很贪婪吗？</p>
<p>1.4 多选分支<br>一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一<br>具体形式如下：(p1|p2|p3)，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一<br>例如要匹配”good”和”nice”可以使用/good|nice/。测试如下<br>var regex = /good|nice/g;<br>var string = “good idea, nice try.”;<br>console.log( string.match(regex) );<br>// =&gt; [“good”, “nice”]<br>但有个事实我们应该注意，比如我用/good|goodbye/，去匹配”goodbye”字符串时，结果是”good”：<br>var regex = /good|goodbye/g;<br>var string = “goodbye”;<br>console.log( string.match(regex) );<br>// =&gt; [“good”]<br>而把正则改成/goodbye|good/，结果是<br> var regex = /goodbye|good/g;<br>var string = “goodbye”;<br>console.log( string.match(regex) );<br>// =&gt; [“goodbye”]<br>也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了</p>
<p>1.5 案例分析<br>匹配字符，无非就是字符组、量词和分支结构的组合使用罢了</p>
<p>1.5.1 匹配16进制颜色值<br>要求匹配</p>
<p>#ffbbad</p>
<p>#Fc01DF</p>
<p>#FFF</p>
<p>#ffE<br>分析</p>
<p>表示一个16进制字符，可以用字符组[0-9a-fA-F]<br>其中字符可以出现3或6次，需要是用量词和分支结构<br>使用分支结构时，需要注意顺序<br>var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;<br>var string = “#ffbbad #Fc01DF #FFF #ffE”;<br>console.log( string.match(regex) );<br>// =&gt; [“#ffbbad”, “#Fc01DF”, “#FFF”, “#ffE”]<br>1.5.2 匹配时间<br>要求匹配</p>
<p>23:59<br>02:07<br>分析</p>
<p>共4位数字，第一位数字可以为[0-2]<br>当第1位为2时，第2位可以为[0-3]，其他情况时，第2位为[0-9]<br>第3位数字为[0-5]，第4位为[0-9]<br>var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;<br>console.log( regex.test(“23:59”) );<br>console.log( regex.test(“02:07”) );<br>// =&gt; true<br>// =&gt; true<br>如果也要求匹配7:9，也就是说时分前面的0可以省略</p>
<p>var regex = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;<br>console.log( regex.test(“23:59”) );<br>console.log( regex.test(“02:07”) );<br>console.log( regex.test(“7:9”) );<br>// =&gt; true<br>// =&gt; true<br>// =&gt; true<br>1.5.3 匹配日期<br>比如yyyy-mm-dd格式为例</p>
<p>要求匹配 2017-06-10</p>
<p>分析</p>
<p>年，四位数字即可，可用[0-9]{4}<br>月，共12个月，分两种情况01、02、……、09和10、11、12，可用(0[1-9]|1[0-2])<br>日，最大31天，可用(0[1-9]|[12][0-9]|3[01])<br>var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;<br>console.log( regex.test(“2017-06-10”) );<br>// =&gt; true<br>1.5.4 window操作系统文件路径<br>F:\study\javascript\regex\regular expression.pdf<br>F:\study\javascript\regex\<br>F:\study\javascript<br>F:\<br>分析</p>
<p>整体模式是: 盘符:\文件夹\文件夹\文件夹\<br>其中匹配F:\，需要使用[a-zA-Z]:\，其中盘符不区分大小写，注意\字符需要转义<br>文件名或者文件夹名，不能包含一些特殊字符，此时我们需要排除字符组[^\:<em>&lt;&gt;|”?\r\n/]来表示合法字符。另外不能为空名，至少有一个字符，也就是要使用量词+。因此匹配“文件夹\”，可用[^\:</em>&lt;&gt;|”?\r\n/]+\<br>另外“文件夹\”，可以出现任意次。也就是([^\:<em>&lt;&gt;|”?\r\n/]+\)</em>。其中括号提供子表达式。<br>路径的最后一部分可以是“文件夹”，没有\，因此需要添加([^\:<em>&lt;&gt;|”?\r\n/]+)?<br>var regex = /^[a-zA-Z]:\([^\:</em>&lt;&gt;|”?\r\n/]+\)<em>([^\:</em>&lt;&gt;|”?\r\n/]+)?$/;<br>console.log( regex.test(“F:\study\javascript\regex\regular expression.pdf”) );<br>console.log( regex.test(“F:\study\javascript\regex\“) );<br>console.log( regex.test(“F:\study\javascript”) );<br>console.log( regex.test(“F:\“) );<br>// =&gt; true<br>// =&gt; true<br>// =&gt; true<br>// =&gt; true<br>其中，JS中字符串表示\时，也要转义</p>
<p>1.5.5 匹配id<br>要求从<div id="container" class="main"></div>中提取出id=”container”</p>
<p>var regex = /id=”.*?”/<br>var string = ‘<div id="container" class="main"></div>‘;<br>console.log(string.match(regex)[0]);<br>// =&gt; id=”container”<br>小结</p>
<p>掌握字符组和量词就能解决大部分常见的情形，也就是说，当你会了这二者，JS正则算是入门了</p>
<p>第二章 正则表达式位置匹配攻略<br>正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话</p>
<p>2.1 什么是位置<br>位置是相邻字符之间的位置。比如，下图中箭头所指的地方</p>
<p>2.2 如何匹配位置<br>在ES5中，共有6个锚字符</p>
<p>^ $ \b \B (?=p) (?!p)<br>2.2.1 $和^<br>^（脱字符）匹配开头，在多行匹配中匹配行开头<br>$（美元符号）匹配结尾，在多行匹配中匹配行结尾<br>比如我们把字符串的开头和结尾用”#”替换（位置可以替换成字符的！</p>
<p>var result = “hello”.replace(/^|$/g, ‘#’);<br>console.log(result);<br>// =&gt; “#hello#”<br>多行匹配模式时，二者是行的概念，这个需要我们的注意</p>
<p>var result = “I\nlove\njavascript”.replace(/^|$/gm, ‘#’);<br>console.log(result);<br>/*</p>
<p>#I#</p>
<p>#love#</p>
<p>#javascript#<br>*<br>2.2.2 \b和\B<br>\b是单词边界，具体就是\w和\W之间的位置，也包括\w和^之间的位置，也包括\w和$之间的位置</p>
<p>比如一个文件名是”[JS] Lesson_01.mp4”中的\b，如下<br>var result = “[JS] Lesson_01.mp4”.replace(/\b/g, ‘#’);<br>console.log(result);<br>// =&gt; “[#JS#] #Lesson_01#.#mp4#”<br>2.2.3 (?=p)和(?!p)<br>(?=p)，其中p是一个子模式，即p前面的位置<br>比如(?=l)，表示’l’字符前面的位置<br>var result = “hello”.replace(/(?=l)/g, ‘#’);<br>console.log(result);<br>// =&gt; “he#l#lo”<br>而(?!p)就是(?=p)的反面意思，比如</p>
<p>var result = “hello”.replace(/(?!l)/g, ‘#’);</p>
<p>console.log(result);<br>// =&gt; “#h#ell#o#”<br>分别是正向先行断言和负向先行断言,具体是(?&lt;=p)和(?&lt;!p)</p>
<p>(?=p)就与^一样好理解，就是p前面的那个位置<br>2.3 位置的特性<br>对于位置的理解，我们可以理解成空字符””<br>比如”hello”字符串等价于如下的形式<br>“hello” == “” + “h” + “” + “e” + “” + “l” + “” + “l” + “o” + “”<br>等价于</p>
<p>“hello” == “” + “” + “hello”<br>因此，把/^hello$/写成/^^hello$$$/，是没有任何问题的</p>
<p>var result = /^^hello$$$/.test(“hello”);<br>console.log(result);<br>// =&gt; true<br>2.4 相关案例<br>2.4.1 不匹配任何东西的正则<br>/.^/<br>2.4.2 数字的千位分隔符表示法<br>比如把”12345678”，变成”12,345,678”</p>
<p>弄出最后一个逗号</p>
<p>使用(?=\d{3}$)就可以做到</p>
<p>var result = “12345678”.replace(/(?=\d{3}$)/g, ‘,’)<br>console.log(result);<br>// =&gt; “12345,678”<br>弄出所有的逗号</p>
<p>因为逗号出现的位置，要求后面3个数字一组，也就是\d{3}至少出现一次</p>
<p>此时可以使用量词+<br>var result = “12345678”.replace(/(?=(\d{3})+$)/g, ‘,’)<br>console.log(result);<br>// =&gt; “12,345,678”<br>匹配其余案例</p>
<p>写完正则后，要多验证几个案例，此时我们会发现问题</p>
<p>var result = “123456789”.replace(/(?=(\d{3})+$)/g, ‘,’)<br>console.log(result);<br>// =&gt; “,123,456,789”<br>因为上面的正则，仅仅表示把从结尾向前数，一但是3的倍数，就把其前面的位置替换成逗号。因此才会出现这个问题<br>我们知道匹配开头可以使用^，但要求这个位置不是开头怎么办<br>(?!^)，你想到了吗？测试如下<br>var string1 = “12345678”,<br>string2 = “123456789”;<br>reg = /(?!^)(?=(\d{3})+$)/g;</p>
<p>var result = string1.replace(reg, ‘,’)<br>console.log(result);<br>// =&gt; “12,345,678”</p>
<p>result = string2.replace(reg, ‘,’);<br>console.log(result);<br>// =&gt; “123,456,789”<br>支持其他形式</p>
<p>如果要把”12345678 123456789”替换成”12,345,678 123,456,789”。</p>
<p>此时我们需要修改正则，把里面的开头^和结尾$，替换成\b<br>var string = “12345678 123456789”,<br>reg = /(?!\b)(?=(\d{3})+\b)/g;</p>
<p>var result = string.replace(reg, ‘,’)<br>console.log(result);<br>// =&gt; “12,345,678 123,456,789”<br>其中(?!\b)怎么理解呢？<br>要求当前是一个位置，但不是\b前面的位置，其实(?!\b)说的就是\B<br>因此最终正则变成了：/\B(?=(\d{3})+\b)/g<br>2.4.3 验证密码问题<br>密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符。<br>此题，如果写成多个正则来判断，比较容易。但要写成一个正则就比较困难。<br>那么，我们就来挑战一下。看看我们对位置的理解是否深刻<br>简化</p>
<p>不考虑“但必须至少包括2种字符”这一条件。我们可以容易写出</p>
<p>var reg = /^[0-9A-Za-z]{6,12}$/;<br>判断是否包含有某一种字符</p>
<p>假设，要求的必须包含数字，怎么办？此时我们可以使用(?=.*[0-9])来做</p>
<p>var reg = /(?=.*[0-9])^[0-9A-Za-z]{6,12}$/;<br>同时包含具体两种字符</p>
<p>比如同时包含数字和小写字母，可以用(?=.<em>[0-9])(?=.</em>[a-z])来做<br>var reg = /(?=.<em>[0-9])(?=.</em>[a-z])^[0-9A-Za-z]{6,12}$/;<br>我们可以把原题变成下列几种情况之一</p>
<p>同时包含数字和小写字母<br>同时包含数字和大写字母<br>同时包含小写字母和大写字母<br>同时包含数字、小写字母和大写字母<br>var reg = /((?=.<em>[0-9])(?=.</em>[a-z])|(?=.<em>[0-9])(?=.</em>[A-Z])|(?=.<em>[a-z])(?=.</em>[A-Z]))^[0-9A-Za-z]{6,12}$/;<br>console.log( reg.test(“1234567”) ); // false 全是数字<br>console.log( reg.test(“abcdef”) ); // false 全是小写字母<br>console.log( reg.test(“ABCDEFGH”) ); // false 全是大写字母<br>console.log( reg.test(“ab23C”) ); // false 不足6位<br>console.log( reg.test(“ABCDEF234”) ); // true 大写字母和数字<br>console.log( reg.test(“abcdEF234”) ); // true 三者都有<br>解惑</p>
<p>/(?=.<em>[0-9])^[0-9A-Za-z]{6,12}$/ 对于这个正则，我们只需要弄明白(?=.</em>[0-9])^即可<br>分开来看就是(?=.<em>[0-9])和^<br>表示开头前面还有个位置<br>(?=.</em>[0-9])表示该位置后面的字符匹配.*[0-9]，即，有任何多个任意字符，后面再跟个数字<br>第三章 正则表达式括号的作用<br>括号的作用，其实三言两语就能说明白，括号提供了分组，便于我们引用它。<br>引用某个分组，会有两种情形：在JavaScript里引用它，在正则表达式里引用它<br>3.1 分组和分支结构<br>这二者是括号最直觉的作用，也是最原始的功能</p>
<p>3.1.1 分组<br>我们知道/a+/匹配连续出现的“a”，而要匹配连续出现的“ab”时，需要使用/(ab)+/<br>其中括号是提供分组功能，使量词+作用于“ab”这个整体，测试如下：<br>var regex = /(ab)+/g;<br>var string = “ababa abbb ababab”;<br>console.log( string.match(regex) );<br>// =&gt; [“abab”, “ab”, “ababab”]<br>3.1.2 分支结构<br>而在多选分支结构(p1|p2)中，此处括号的作用也是不言而喻的，提供了子表达式的所有可能</p>
<p>I love JavaScript<br>I love Regular Expression<br>var regex = /^I love (JavaScript|Regular Expression)$/;<br>console.log( regex.test(“I love JavaScript”) );<br>console.log( regex.test(“I love Regular Expression”) );<br>// =&gt; true<br>// =&gt; true<br>如果去掉正则中的括号，即 /^I love JavaScript|Regular Expression$/，匹配字符串是”I love JavaScript”和”Regular Expression”，当然这不是我们想要的<br>3.2 引用分组<br>这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作<br>而要使用它带来的好处，必须配合使用实现环境的API<br>以日期为例。假设格式是yyyy-mm-dd的，我们可以先写一个简单的正则<br>var regex = /\d{4}-\d{2}-\d{2}/;<br>然后再修改成括号版的：</p>
<p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>为什么要使用这个正则呢</p>
<p>提取数据</p>
<p>比如提取出年、月、日，可以这么做</p>
<p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;<br>console.log( string.match(regex) );<br>// =&gt; [“2017-06-12”, “2017”, “06”, “12”, index: 0, input: “2017-06-12”]<br>match返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。（注意：如果正则是否有修饰符g，match返回的数组格式是不一样的）</p>
<p>另外也可以使用正则对象的exec方法<br>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;<br>console.log( regex.exec(string) );<br>// =&gt; [“2017-06-12”, “2017”, “06”, “12”, index: 0, input: “2017-06-12”]<br>同时，也可以使用构造函数的全局属性$1至$9来获取</p>
<p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;</p>
<p>regex.test(string); // 正则操作即可，例如<br>//regex.exec(string);<br>//string.match(regex);</p>
<p>console.log(RegExp.$1); // “2017”<br>console.log(RegExp.$2); // “06”<br>console.log(RegExp.$3); // “12”<br>替换</p>
<p>想把yyyy-mm-dd格式，替换成mm/dd/yyyy怎么做</p>
<p>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;<br>var result = string.replace(regex, “$2/$3/$1”);<br>console.log(result);<br>// =&gt; “06/12/2017”<br>其中replace中的，第二个参数里用$1、$2、$3指代相应的分组。等价于如下的形式：var regex = /(\d{4})-(\d{2})-(\d{2})/;</p>
<p>var string = “2017-06-12”;<br>var result = string.replace(regex, function() {<br>    return RegExp.$2 + “/“ + RegExp.$3 + “/“ + RegExp.$1;<br>});<br>console.log(result);<br>// =&gt; “06/12/2017”<br>也等价于：<br>var regex = /(\d{4})-(\d{2})-(\d{2})/;<br>var string = “2017-06-12”;<br>var result = string.replace(regex, function(match, year, month, day) {<br>    return month + “/“ + day + “/“ + year;<br>});<br>console.log(result);<br>// =&gt; “06/12/2017”<br>3.3 反向引用<br>除了使用相应API来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。</p>
<p>比如要写一个正则支持匹配如下三种格式</p>
<p>2016-06-12<br>2016-06-12<br>2016.06.12<br>最先可能想到的正则是:</p>
<p>var regex = /\d{4}(-|\/|.)\d{2}(-|\/|.)\d{2}/;<br>var string1 = “2017-06-12”;<br>var string2 = “2017/06/12”;<br>var string3 = “2017.06.12”;<br>var string4 = “2016-06/12”;<br>console.log( regex.test(string1) ); // true<br>console.log( regex.test(string2) ); // true<br>console.log( regex.test(string3) ); // true<br>console.log( regex.test(string4) ); // true<br>其中/和.需要转义。虽然匹配了要求的情况，但也匹配”2016-06/12”这样的数据</p>
<p>假设我们想要求分割符前后一致怎么办？此时需要使用反向引用<br>var regex = /\d{4}(-|\/|.)\d{2}\1\d{2}/;<br>var string1 = “2017-06-12”;<br>var string2 = “2017/06/12”;<br>var string3 = “2017.06.12”;<br>var string4 = “2016-06/12”;<br>console.log( regex.test(string1) ); // true<br>console.log( regex.test(string2) ); // true<br>console.log( regex.test(string3) ); // true<br>console.log( regex.test(string4) ); // false<br>注意里面的\1，表示的引用之前的那个分组(-|\/|.)。不管它匹配到什么（比如-），\1都匹配那个同样的具体某个字符<br>我们知道了\1的含义后，那么\2和\3的概念也就理解了，即分别指代第二个和第三个分组<br>看到这里，此时，恐怕你会有三个问题</p>
<p>括号嵌套怎么办？</p>
<p>以左括号（开括号）为准。比如：</p>
<p>var regex = /^((\d)(\d(\d)))\1\2\3\4$/;<br>var string = “1231231233”;<br>console.log( regex.test(string) ); // true<br>console.log( RegExp.$1 ); // 123<br>console.log( RegExp.$2 ); // 1<br>console.log( RegExp.$3 ); // 23<br>console.log( RegExp.$4 ); // 3<br>我们可以看看这个正则匹配模式：</p>
<p>第一个字符是数字，比如说1，<br>第二个字符是数字，比如说2，<br>第三个字符是数字，比如说3，<br>接下来的是\1，是第一个分组内容，那么看第一个开括号对应的分组是什么，是123，<br>接下来的是\2，找到第2个开括号，对应的分组，匹配的内容是1，<br>接下来的是\3，找到第3个开括号，对应的分组，匹配的内容是23，<br>最后的是\4，找到第3个开括号，对应的分组，匹配的内容是3。<br>引用不存在的分组会怎样？</p>
<p>因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。例如\2，就匹配”\2”。注意”\2”表示对”2”进行了转意</p>
<p>var regex = /\1\2\3\4\5\6\7\8\9/;<br>console.log( regex.test(“\1\2\3\4\5\6\7\8\9”) );<br>console.log( “\1\2\3\4\5\6\7\8\9”.split(“”) );<br>3.4 非捕获分组<br>之前文中出现的分组，都会捕获它们匹配到的数据，以便后续引用，因此也称他们是捕获型分组<br>如果只想要括号最原始的功能，但不会引用它，即，既不在API里引用，也不在正则里反向引用。此时可以使用非捕获分组(?:p)，例如本文第一个例子可以修改为：<br>var regex = /(?:ab)+/g;<br>var string = “ababa abbb ababab”;<br>console.log( string.match(regex) );<br>// =&gt; [“abab”, “ab”, “ababab”]<br>3.5 相关案例<br>至此括号的作用已经讲完了，总结一句话，就是提供了可供我们使用的分组，如何用就看我们的了</p>
<p>3.5.1 字符串trim方法模拟<br>trim方法是去掉字符串的开头和结尾的空白符。有两种思路去做</p>
<p>第一种，匹配到开头和结尾的空白符，然后替换成空字符。如<br>function trim(str) {<br>    return str.replace(/^\s+|\s+$/g, ‘’);<br>}<br>console.log( trim(“  foobar   “) );<br>// =&gt; “foobar”<br>第二种，匹配整个字符串，然后用引用来提取出相应的数据<br>function trim(str) {<br>    return str.replace(/^\s<em>(.</em>?)\s<em>$/g, “$1”);<br>}<br>console.log( trim(“  foobar   “) );<br>// =&gt; “foobar”<br>这里使用了惰性匹配</em>?，不然也会匹配最后一个空格之前的所有空格的</p>
<p>3.5.2 将每个单词的首字母转换为大写<br>function titleize(str) {<br>    return str.toLowerCase().replace(/(?:^|\s)\w/g, function(c) {<br>        return c.toUpperCase();<br>    });<br>}<br>console.log( titleize(‘my name is epeli’) );<br>// =&gt; “My Name Is Epeli”<br>思路是找到每个单词的首字母，当然这里不使用非捕获匹配也是可以的。</p>
<p>3.5.3 驼峰化<br>function camelize(str) {<br>    return str.replace(/[-_\s]+(.)?/g, function(match, c) {<br>        return c ? c.toUpperCase() : ‘’;<br>    });<br>}<br>console.log( camelize(‘-moz-transform’) );<br>// =&gt; “MozTransform”<br>其中分组(.)表示首字母。单词的界定是，前面的字符可以是多个连字符、下划线以及空白符。正则后面的?的目的，是为了应对str尾部的字符可能不是单词字符，比如str是’-moz-transform ‘</p>
<p>3.5.4 中划线化<br>驼峰化的逆过程</p>
<p>function dasherize(str) {<br>    return str.replace(/([A-Z])/g, ‘-$1’).replace(/[-_\s]+/g, ‘-‘).toLowerCase();<br>}<br>console.log( dasherize(‘MozTransform’) );<br>// =&gt; “-moz-transform”<br>3.5.5 html转义和反转义<br>// 将HTML特殊字符转换成等值的实体<br>function escapeHTML(str) {<br>    var escapeChars = {<br>      ‘¢’ : ‘cent’,<br>      ‘£’ : ‘pound’,<br>      ‘¥’ : ‘yen’,<br>      ‘€’: ‘euro’,<br>      ‘©’ :’copy’,<br>      ‘®’ : ‘reg’,<br>      ‘&lt;’ : ‘lt’,<br>      ‘&gt;’ : ‘gt’,<br>      ‘“‘ : ‘quot’,<br>      ‘&amp;’ : ‘amp’,<br>      ‘\’’ : ‘#39’<br>    };<br>    return str.replace(new RegExp(‘[‘ + Object.keys(escapeChars).join(‘’) +’]’, ‘g’), function(match) {<br>        return ‘&amp;’ + escapeChars[match] + ‘;’;<br>    });<br>}<br>console.log( escapeHTML(‘<div>Blah blah blah</div>‘) );<br>// =&gt; “&lt;div&gt;Blah blah blah&lt;/div&amp;gt”;<br>其中使用了用构造函数生成的正则，然后替换相应的格式就行了</p>
<p>倒是它的逆过程，使用了括号，以便提供引用，也很简单<br>// 实体字符转换为等值的HTML。<br>function unescapeHTML(str) {<br>    var htmlEntities = {<br>      nbsp: ‘ ‘,<br>      cent: ‘¢’,<br>      pound: ‘£’,<br>      yen: ‘¥’,<br>      euro: ‘€’,<br>      copy: ‘©’,<br>      reg: ‘®’,<br>      lt: ‘&lt;’,<br>      gt: ‘&gt;’,<br>      quot: ‘“‘,<br>      amp: ‘&amp;’,<br>      apos: ‘\’’<br>    };<br>    return str.replace(/\&amp;([^;]+);/g, function(match, key) {<br>        if (key in htmlEntities) {<br>            return htmlEntities[key];<br>        }<br>        return match;<br>    });<br>}<br>console.log( unescapeHTML(‘&lt;div&gt;Blah blah blah&lt;/div&gt;’) );<br>// =&gt; “<div>Blah blah blah</div>“<br>通过key获取相应的分组引用，然后作为对象的键</p>
<p>3.5.6 匹配成对标签<br>要求匹配</p>
<p><title>regular expression</title></p>
<p></p><p>laoyao bye bye</p><br>不匹配<p></p>
<p><title>wrong!</title></p><br>匹配一个开标签，可以使用正则&lt;[^&gt;]+&gt;，<br>匹配一个闭标签，可以使用&lt;\/[^&gt;]+&gt;<br>但是要求匹配成对标签，那就需要使用反向引用，如：<p></p>
<p>var regex = /&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/;<br>var string1 = “<title>regular expression</title>“;<br>var string2 = “</p><p>laoyao bye bye</p>“;<br>var string3 = “<title>wrong!<p></p>“;<br>console.log( regex.test(string1) ); // true<br>console.log( regex.test(string2) ); // true<br>console.log( regex.test(string3) ); // false<br>其中开标签&lt;[^&gt;]+&gt;改成&lt;([^&gt;]+)&gt;，使用括号的目的是为了后面使用反向引用，而提供分组。<br>闭标签使用了反向引用，&lt;\/\1&gt;<br>另外[\d\D]的意思是，这个字符是数字或者不是数字，因此，也就是匹配任意字符的意思<br>第4章 正则表达式回溯法原理<br>4.1 没有回溯的匹配<br>假设我们的正则是/ab{1,3}c/，其可视化形式是<p></p>
<p>而当目标字符串是”abbbc”时，就没有所谓的“回溯”。其匹配过程是：</p>
<p>其中子表达式b{1,3}表示“b”字符连续出现1到3次</p>
<p>4.2 有回溯的匹配<br>如果目标字符串是”abbc”，中间就有回溯</p>
<p>图中第5步有红颜色，表示匹配不成功。此时b{1,3}已经匹配到了2个字符“b”，准备尝试第三个时，结果发现接下来的字符是“c”。那么就认为b{1,3}就已经匹配完毕。然后状态又回到之前的状态（即第6步，与第4步一样），最后再用子表达式c，去匹配字符“c”。当然，此时整个表达式匹配成功了</p>
<p>图中的第6步，就是“回溯”<br>你可能对此没有感觉，这里我们再举一个例子。正则是</p>
<p>目标字符串是：”acd”ef，匹配过程是</p>
<p>图中省略了尝试匹配双引号失败的过程。可以看出.<em>是非常影响效率的。<br>为了减少一些不必要的回溯，可以把正则修改为/“[^”]</em>“/<br>4.3 常见的回溯形式<br>正则表达式匹配字符串的这种方式，有个学名，叫回溯法</p>
<p>回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”<br>本质上就是深度优先搜索算法。其中退到之前的某一步这一过程，我们称为“回溯”。从上面的描述过程中，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯<br>那么JS中正则表达式会产生回溯的地方都有哪些呢</p>
<p>贪婪量词</p>
<p>之前的例子都是贪婪量词相关的。比如b{1,3}，因为其是贪婪的，尝试可能的顺序是从多往少的方向去尝试。首先会尝试”bbb”，然后再看整个正则是否能匹配。不能匹配时，吐出一个”b”，即在”bb”的基础上，再继续尝试。如果还不行，再吐出一个，再试。如果还不行呢？只能说明匹配失败了。</p>
<p>虽然局部匹配是贪婪的，但也要满足整体能正确匹配<br>如果当多个贪婪量词挨着存在，并相互有冲突时，此时会是怎样？<br>答案是，先下手为强！因为深度优先搜索。测试如下：<br>var string = “12345”;<br>var regex = /(\d{1,3})(\d{1,3})/;<br>console.log( string.match(regex) );<br>// =&gt; [“12345”, “123”, “45”, index: 0, input: “12345”]<br>其中，前面的\d{1,3}匹配的是”123”，后面的\d{1,3}匹配的是”45”</p>
<p>惰性量词</p>
<p>惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配，比如</p>
<p>var string = “12345”;<br>var regex = /(\d{1,3}?)(\d{1,3})/;<br>console.log( string.match(regex) );<br>// =&gt; [“1234”, “1”, “234”, index: 0, input: “12345”]<br>其中\d{1,3}?只匹配到一个字符”1”，而后面的\d{1,3}匹配了”234”<br>虽然惰性量词不贪，但也会有回溯的现象。比如正则是：</p>
<p>目标字符串是”12345”，匹配过程是</p>
<p>知道你不贪、很知足，但是为了整体匹配成，没办法，也只能给你多塞点了。因此最后\d{1,3}?匹配的字符是”12”，是两个数字，而不是一个</p>
<p>分支结构</p>
<p>我们知道分支也是惰性的，比如/can|candy/，去匹配字符串”candy”，得到的结果是”can”，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了。分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分支。这种尝试也可以看成一种回溯</p>
<p>目标字符串是”candy”，匹配过程</p>
<p>小结</p>
<p>简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了；要么最后都试完后，发现整体匹配不成功</p>
<p>贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。<br>惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点<br>分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换<br>第5章 正则表达式的拆分<br>5.1 结构和操作符<br>而在正则表达式中，操作符都体现在结构中，即由特殊字符和普通字符所代表的一个个特殊整体。</p>
<p>JS正则表达式中，都有哪些结构呢？</p>
<p>字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用<br>具体含义简要回顾如下</p>
<p>字面量，匹配一个具体字符，包括不用转义的和需要转义的。比如a匹配字符”a”，又比如\n匹配换行符，又比如.匹配小数点。<br>字符组，匹配一个字符，可以是多种可能之一，比如[0-9]，表示匹配一个数字。也有\d的简写形式。另外还有反义字符组，表示可以是除了特定字符之外任何一个字符，比如[^0-9]，表示一个非数字字符，也有\D的简写形式。<br>量词，表示一个字符连续出现，比如a{1,3}表示“a”字符连续出现3次。另外还有常见的简写形式，比如a+表示“a”字符连续出现至少一次。<br>锚点，匹配一个位置，而不是字符。比如^匹配字符串的开头，又比如\b匹配单词边界，又比如(?=\d)表示数字前面的位置。<br>分组，用括号表示一个整体，比如(ab)+，表示”ab”两个字符连续出现多次，也可以使用非捕获分组(?:ab)+。<br>分支，多个子表达式多选一，比如abc|bcd，表达式匹配”abc”或者”bcd”字符子串。<br>反向引用，比如\2，表示引用第2个分组<br>其中涉及到的操作符有</p>
<p>转义符 \<br>括号和方括号(…)、(?:…)、(?=…)、(?!…)、[…]<br>量词限定符 {m}、{m,n}、{m,}、?、*、+<br>位置和序列 ^ 、$、 \元字符、 一般字符<br>管道符（竖杠）|<br>上面操作符的优先级从上至下，由高到低</p>
<p>这里，我们来分析一个正则</p>
<p>/ab?(c|de<em>)+|fg/<br>由于括号的存在，所以，(c|de</em>)是一个整体结构<br>在(c|de<em>)中，注意其中的量词，因此e是一个整体结构<br>又因为分支结构“|”优先级最低，因此c是一个整体、而de</em>是另一个整体<br>同理，整个正则分成了 a、b?、(…)+、f、g。而由于分支的原因，又可以分成ab?(c|de*)+和fg这两部分</p>
<p>5.2 注意要点<br>匹配字符串整体问题</p>
<p>因为是要匹配整个字符串，我们经常会在正则前后中加上锚字符^和$<br>比如要匹配目标字符串”abc”或者”bcd”时，如果一不小心，就会写成/^abc|bcd$/<br>量词连缀问题</p>
<p>假设，要匹配这样的字符串</p>
<p>每个字符为a、b、c任选其一<br>字符串的长度是3的倍数<br>此时正则不能想当然地写成/^[abc]{3}+$/，这样会报错，说+前面没什么可重复的<br>此时要修改成 /([abc]{3})/<br>元字符转义问题</p>
<p>所谓元字符，就是正则中有特殊含义的字符<br>所有结构里，用到的元字符总结如下<br>^ $ . * + ? | \ / ( ) [ ] { } = ! : - ,<br>当匹配上面的字符本身时，可以一律转义</p>
<p>var string = “^$.<em>+?|\/[]{}=!:-,”;<br>var regex = /\^\$.\</em>+\?|\\/[]{}\=!\:-\,/;<br>console.log( regex.test(string) );<br>// =&gt; true<br>其中string中的\字符也要转义的<br>另外，在string中，也可以把每个字符转义，当然，转义后的结果仍是本身<br>var string = “^$.<em>+?|\/[]{}=!:-,”;<br>var string2 = “\^\$.\</em>+\?|\\/[]{}\=!\:-\,”;<br>console.log( string == string2 );<br>// =&gt; true<br>字符组中的元字符</p>
<p>跟字符组相关的元字符有[]、^、-。因此在会引起歧义的地方进行转义。例如开头的^必须转义，不然会把整个字符组，看成反义字符组</p>
<p>var string = “^$.<em>+?|\/[]{}=!:-,”;<br>var regex = /[\^$.</em>+?|\/[]{}=!:-,]/g;<br>console.log( string.match(regex) );<br>// =&gt; [“^”, “$”, “.”, “*”, “+”, “?”, “|”, “\”, “/“, “[“, “]”, “{“, “}”, “=”, “!”, “:”, “-“, “,”]<br>5.3 案例分析<br>身份证</p>
<p>/^(\d{15}|\d{17}[\dxX])$/<br>因为竖杠“|”,的优先级最低，所以正则分成了两部分\d{15}和\d{17}[\dxX]</p>
<p>\d{15}表示15位连续数字<br>\d{17}[\dxX]表示17位连续数字，最后一位可以是数字可以大小写字母”x”<br>IPV4地址</p>
<p>/^((0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5]).){3}(0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])$/<br>得出如下的结构：</p>
<p>((…).){3}(…)<br>上面的两个(…)是一样的结构。表示匹配的是3位数字。因此整个结构是</p>
<p>3位数.3位数.3位数.3位数<br>然后再来分析(…)</p>
<p>(0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])(0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])<br>它是一个多选结构，分成5个部分</p>
<p>0{0,2}\d，匹配一位数，包括0补齐的。比如，9、09、009；<br>0?\d{2}，匹配两位数，包括0补齐的，也包括一位数；<br>1\d{2}，匹配100到199;<br>2[0-4]\d，匹配200-249；<br>25[0-5]，匹配250-255。<br>第六章 正则表达式编程<br>6.1 正则表达式的四种操作<br>6.1.1 验证<br>验证是正则表达式最直接的应用，比如表单验证<br>在说验证之前，先要说清楚匹配是什么概念<br>所谓匹配，就是看目标字符串里是否有满足匹配的子串。因此，“匹配”的本质就是“查找”<br>比如，判断一个字符串中是否有数字</p>
<p>使用search</p>
<p>var regex = /\d/;<br>var string = “abc123”;<br>console.log( !!~string.search(regex) );<br>// =&gt; true<br>使用test</p>
<p>var regex = /\d/;<br>var string = “abc123”;<br>console.log( regex.test(string) );<br>// =&gt; true<br>使用match</p>
<p>var regex = /\d/;<br>var string = “abc123”;<br>console.log( !!string.match(regex) );<br>// =&gt; true<br>使用exec</p>
<p>var regex = /\d/;<br>var string = “abc123”;<br>console.log( !!regex.exec(string) );<br>// =&gt; true<br>其中，最常用的是test</p>
<p>6.1.2 切分<br>匹配上了，我们就可以进行一些操作，比如切分<br>所谓“切分”，就是把目标字符串，切成一段一段的。在JS中使用的是split<br>比如，目标字符串是”html,css,javascript”，按逗号来切分<br>var regex = /,/;<br>var string = “html,css,javascript”;<br>console.log( string.split(regex) );<br>// =&gt; [“html”, “css”, “javascript”]<br>又比如，如下的日期格式</p>
<p>2017/06/26<br>2017.06.26<br>2017-06-26<br>可以使用split“切出”年月日</p>
<p>var regex = /\D/;<br>console.log( “2017/06/26”.split(regex) );<br>console.log( “2017.06.26”.split(regex) );<br>console.log( “2017-06-26”.split(regex) );<br>// =&gt; [“2017”, “06”, “26”]<br>// =&gt; [“2017”, “06”, “26”]<br>// =&gt; [“2017”, “06”, “26”]<br>6.1.3 提取<br>虽然整体匹配上了，但有时需要提取部分匹配的数据<br>此时正则通常要使用分组引用（分组捕获）功能，还需要配合使用相关API。<br>这里，还是以日期为例，提取出年月日。注意下面正则中的括号</p>
<p>match</p>
<p>var regex = /^(\d{4})\D(\d{2})\D(\d{2})$/;<br>var string = “2017-06-26”;<br>console.log( string.match(regex) );<br>// =&gt;[“2017-06-26”, “2017”, “06”, “26”, index: 0, input: “2017-06-26”]<br>exec</p>
<p>var regex = /^(\d{4})\D(\d{2})\D(\d{2})$/;<br>var string = “2017-06-26”;<br>console.log( regex.exec(string) );<br>// =&gt;[“2017-06-26”, “2017”, “06”, “26”, index: 0, input: “2017-06-26”]<br>test</p>
<p>var regex = /^(\d{4})\D(\d{2})\D(\d{2})$/;<br>var string = “2017-06-26”;<br>regex.test(string);<br>console.log( RegExp.$1, RegExp.$2, RegExp.$3 );<br>// =&gt; “2017” “06” “26”<br>search</p>
<p>var regex = /^(\d{4})\D(\d{2})\D(\d{2})$/;<br>var string = “2017-06-26”;<br>string.search(regex);<br>console.log( RegExp.$1, RegExp.$2, RegExp.$3 );<br>// =&gt; “2017” “06” “26”<br>replace</p>
<p>var regex = /^(\d{4})\D(\d{2})\D(\d{2})$/;<br>var string = “2017-06-26”;<br>var date = [];<br>string.replace(regex, function(match, year, month, day) {<br>    date.push(year, month, day);<br>});<br>console.log(date);<br>// =&gt; [“2017”, “06”, “26”]<br>其中，最常用的是match</p>
<p>6.1.4 替换<br>找，往往不是目的，通常下一步是为了替换。在JS中，使用replace进行替换</p>
<p>比如把日期格式，从yyyy-mm-dd替换成yyyy/mm/dd：</p>
<p>var string = “2017-06-26”;<br>var today = new Date( string.replace(/-/g, “/“) );<br>console.log( today );<br>// =&gt; Mon Jun 26 2017 00:00:00 GMT+0800 (中国标准时间)<br>6.2 相关API注意要点<br>从上面可以看出用于正则操作的方法，共有6个，字符串实例4个，正则实例2个</p>
<p>String#search</p>
<p>String#split</p>
<p>String#match</p>
<p>String#replace</p>
<p>RegExp#test</p>
<p>RegExp#exec</p>
<p>search和match的参数问题</p>
<p>我们知道字符串实例的那4个方法参数都支持正则和字符串<br>但search和match，会把字符串转换为正则的<br>var string = “2017.06.27”;</p>
<p>console.log( string.search(“.”) );<br>// =&gt; 0<br>//需要修改成下列形式之一<br>console.log( string.search(“\.”) );<br>console.log( string.search(/./) );<br>// =&gt; 4<br>// =&gt; 4</p>
<p>console.log( string.match(“.”) );<br>// =&gt; [“2”, index: 0, input: “2017.06.27”]<br>//需要修改成下列形式之一<br>console.log( string.match(“\.”) );<br>console.log( string.match(/./) );<br>// =&gt; [“.”, index: 4, input: “2017.06.27”]<br>// =&gt; [“.”, index: 4, input: “2017.06.27”]</p>
<p>console.log( string.split(“.”) );<br>// =&gt; [“2017”, “06”, “27”]</p>
<p>console.log( string.replace(“.”, “/“) );<br>// =&gt; “2017/06.27”<br>match返回结果的格式问题</p>
<p>match返回结果的格式，与正则对象是否有修饰符g有关</p>
<p>var string = “2017.06.27”;<br>var regex1 = /\b(\d+)\b/;<br>var regex2 = /\b(\d+)\b/g;<br>console.log( string.match(regex1) );<br>console.log( string.match(regex2) );<br>// =&gt; [“2017”, “2017”, index: 0, input: “2017.06.27”]<br>// =&gt; [“2017”, “06”, “27”]<br>没有g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。<br>有g，返回的是所有匹配的内容。<br>当没有匹配时，不管有无g，都返回null<br>exec比match更强大</p>
<p>当正则没有g时，使用match返回的信息比较多。但是有g后，就没有关键的信息index了</p>
<p>而exec方法就能解决这个问题，它能接着上一次匹配后继续匹配<br>var string = “2017.06.27”;<br>var regex2 = /\b(\d+)\b/g;<br>console.log( regex2.exec(string) );<br>console.log( regex2.lastIndex);<br>console.log( regex2.exec(string) );<br>console.log( regex2.lastIndex);<br>console.log( regex2.exec(string) );<br>console.log( regex2.lastIndex);<br>console.log( regex2.exec(string) );<br>console.log( regex2.lastIndex);<br>// =&gt; [“2017”, “2017”, index: 0, input: “2017.06.27”]<br>// =&gt; 4<br>// =&gt; [“06”, “06”, index: 5, input: “2017.06.27”]<br>// =&gt; 7<br>// =&gt; [“27”, “27”, index: 8, input: “2017.06.27”]<br>// =&gt; 10<br>// =&gt; null<br>// =&gt; 0<br>test整体匹配时需要使用^和$</p>
<p>这个相对容易理解，因为test是看目标字符串中是否有子串匹配正则，即有部分匹配即可</p>
<p>如果，要整体匹配，正则前后需要添加开头和结尾<br>console.log( /123/.test(“a123b”) );<br>// =&gt; true<br>console.log( /^123$/.test(“a123b”) );<br>// =&gt; false<br>console.log( /^123$/.test(“123”) );<br>// =&gt; true<br>split相关注意事项</p>
<p>split方法看起来不起眼，但要注意的地方有两个的<br>第一，它可以有第二个参数，表示结果数组的最大长度</p>
<p>var string = “html,css,javascript”;<br>console.log( string.split(/,/, 2) );<br>// =&gt;[“html”, “css”]<br>第二，正则使用分组时，结果数组中是包含分隔符的</p>
<p>var string = “html,css,javascript”;<br>console.log( string.split(/(,)/) );<br>// =&gt;[“html”, “,”, “css”, “,”, “javascript”]<br>replace是很强大的</p>
<p>总体来说replace有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数</p>
<p>当第二个参数是字符串时，如下的字符有特殊的含义</p>
<p>$1,$2,…,$99 匹配第1~99个分组里捕获的文本<br>$&amp; 匹配到的子串文本<br>$` 匹配到的子串的左边文本<br>$’ 匹配到的子串的右边文本<br>$$ 美元符号<br>例如，把”2,3,5”，变成”5=2+3”：</p>
<p>var result = “2,3,5”.replace(/(\d+),(\d+),(\d+)/, “$3=$1+$2”);<br>console.log(result);<br>// =&gt; “5=2+3”<br>当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么</p>
<p>“1234 2345 3456”.replace(/(\d)\d{2}(\d)/g, function(match, $1, $2, index, input) {<br>    console.log([match, $1, $2, index, input]);<br>});<br>// =&gt; [“1234”, “1”, “4”, 0, “1234 2345 3456”]<br>// =&gt; [“2345”, “2”, “5”, 5, “1234 2345 3456”]<br>// =&gt; [“3456”, “3”, “6”, 10, “1234 2345 3456”]<br>此时我们可以看到replace拿到的信息，并不比exec少</p>
<p>修饰符</p>
<p>g 全局匹配，即找到所有匹配的，单词是global<br>i 忽略字母大小写，单词ingoreCase<br>m 多行匹配，只影响^和$，二者变成行的概念，即行开头和行结尾。单词是multiline</p>
</title>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Inici</a></li>
         
          <li><a href="/about/">Qui som</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/projects_url">Projectes</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/01/15/正则表达式学习/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/01/15/正则表达式学习/&text=正则表达式学习"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/01/15/正则表达式学习/&title=正则表达式学习"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/01/15/正则表达式学习/&is_video=false&description=正则表达式学习"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=正则表达式学习&body=Check out this article: http://yoursite.com/2019/01/15/正则表达式学习/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/01/15/正则表达式学习/&title=正则表达式学习"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/01/15/正则表达式学习/&title=正则表达式学习"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/01/15/正则表达式学习/&title=正则表达式学习"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/01/15/正则表达式学习/&title=正则表达式学习"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/01/15/正则表达式学习/&name=正则表达式学习&description=&lt;p&gt;&lt;strong&gt;第一章 正则表达式字符匹配攻略&lt;/strong&gt;&lt;br&gt;1.1 两种模糊匹配&lt;br&gt;如果正则只有精确匹配是没多大意义的，比如/hello/，也只能匹配字符串中的”hello”这个子串&lt;/p&gt;
&lt;p&gt;var regex = /hello/;&lt;br&gt;console.log( regex.test(“hello”) );&lt;br&gt;// =&amp;gt; true&lt;br&gt;正则表达式之所以强大，是因为其能实现模糊匹配&lt;br&gt;而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊&lt;br&gt;1.1.1 横向模糊匹配&lt;br&gt;横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的&lt;br&gt;其实现的方式是使用量词。譬如{m,n}，表示连续出现最少m次，最多n次&lt;br&gt;比如/ab{2,5}c/表示匹配这样一个字符串：第一个字符是“a”，接下来是2到5个字符“b”，最后是字符“c”。测试如下&lt;br&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menú</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Compartir</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Cap amunt</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 大可
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Inici</a></li>
         
          <li><a href="/about/">Qui som</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/projects_url">Projectes</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
